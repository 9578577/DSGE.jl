<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimating the Model · DSGE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="DSGE.jl logo"/></a><h1>DSGE.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="model_design.html">Model Design</a></li><li><a class="toctext" href="running_existing_model.html">Running An Existing Model</a></li><li><a class="toctext" href="advanced_usage.html">Advanced Usage</a></li><li><a class="toctext" href="input_data.html">Input Data</a></li><li><a class="toctext" href="frbny_data.html">FRBNY Model Input Data</a></li><li><a class="toctext" href="implementation_details.html">Implementation Details</a></li><li><a class="toctext" href="solving.html">Solving the Model</a></li><li class="current"><a class="toctext" href="estimation.html">Estimating the Model</a><ul class="internal"><li><a class="toctext" href="#Procedure-1">Procedure</a></li><li><a class="toctext" href="#Computing-the-Posterior-1">Computing the Posterior</a></li><li><a class="toctext" href="#estimation-reoptimizing-1">Optimizing or Reoptimizing</a></li><li><a class="toctext" href="#Calculating-the-Hessian-1">Calculating the Hessian</a></li><li><a class="toctext" href="#Estimation-routines-1">Estimation routines</a></li></ul></li><li><a class="toctext" href="algorithms.html">Algorithms</a></li><li><a class="toctext" href="contributing.html">Contributing to DSGE.jl</a></li><li><a class="toctext" href="MatlabToJuliaTransition.html">MATLAB to Julia Transition</a></li><li><a class="toctext" href="license.html">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="estimation.html">Estimating the Model</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/86f9a1cf0bf2dd0f25167770180c891f819ad8c7/docs/src/estimation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Estimation-1" href="#Estimation-1">Estimation</a></h1><h2><a class="nav-anchor" id="Procedure-1" href="#Procedure-1">Procedure</a></h2><p>The goal of the estimation step is to sample from the posterior distribution of the model parameters. DSGE.jl uses a Metropolis-Hastings sampler to do this, which requires as a proposal covariance matrix the Hessian matrix corresponding to the posterior mode. The function <code>estimate</code> implements the entire procedure. </p><p><strong>Main Steps</strong>:</p><ul><li><em>Initialization</em>: Read in and transform raw data from <code>save/input_data/</code>. See <a href="input_data.html#Input-Data-1">Input Data</a> for more details.  </li></ul><ul><li><em>Reoptimize parameter vector</em>: The main program will call the <code>csminwel</code>   optimization routine (located in <code>csminwel.jl</code>) to find modal parameter   estimates.</li></ul><ul><li><em>Compute Hessian matrix</em>: Computing the Hessian matrix to scale the   proposal distribution in the Metropolis-Hastings algorithm.</li></ul><ul><li><em>Sample from Posterior</em>: Posterior sampling is performed using the   Metropolis-Hastings algorithm. A proposal distribution is constructed centered   at the posterior mode and with proposal covariance scaled by the inverse of   the Hessian matrix. Settings for the number of sampling blocks and the size of   those blocks can be altered as described in   <a href="advanced_usage.html#editing-extending-model-1">Editing or Extending a Model</a>.</li></ul><p><strong>Remark</strong>: In addition to saving each <code>mh_thin</code>-th draw of the parameter vector, the estimation program also saves the resulting posterior value and transition equation matrices implied by each draw of the parameter vector. This is to save time in the forecasting step since that code can avoid recomputing those matrices.</p><p>To run the entire procedure, the user simply calls the <code>estimate</code> routine:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.estimate" href="#DSGE.estimate"><code>DSGE.estimate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">estimate(m, data; verbose=:low, proposal_covariance=Matrix())</code></pre><p>Estimate the DSGE parameter posterior distribution.</p><p><strong>Arguments:</strong></p><ul><li><code>m::AbstractModel</code>: model object</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>data</code>: well-formed data as <code>Matrix</code> or <code>DataFrame</code>. If this is not provided, the <code>load_data</code> routine will be executed.</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>verbose::Symbol</code>: The desired frequency of function progress messages printed to standard out.</li><li><code>:none</code>: No status updates will be reported.</li><li><code>:low</code>: Status updates will be provided in csminwel and at each block in      Metropolis-Hastings.</li><li><code>:high</code>: Status updates provided at each iteration in Metropolis-Hastings.</li><li><code>proposal_covariance::Matrix</code>: Used to test the metropolis_hastings algorithm with a precomputed   covariance matrix for the proposal distribution. When the Hessian is singular,   eigenvectors corresponding to zero eigenvectors are not well defined, so eigenvalue   decomposition can cause problems. Passing a precomputed matrix allows us to ensure that   the rest of the routine has not broken. </li></ul></div></section><h2><a class="nav-anchor" id="Computing-the-Posterior-1" href="#Computing-the-Posterior-1">Computing the Posterior</a></h2><p>In DSGE.jl, the function <code>posterior</code> computes the value of the posterior distribution at a given parameter vector. It calls the <code>likelihood</code> function, which in turn calls the <code>kalman_filter</code> routine. See <a href="estimation.html#Estimation-routines-1">Estimation routines</a> for more details on these functions.</p><p>We implement the Kalman Filter via the <code>kalman_filter</code> function to compute the log-likelihood, and add this to the log prior to obtain the log posterior. See <a href="algorithms.html#State-Space-Routines-1">State Space Routines</a> for a model-independent implementations of the Kalman filter.	</p><h2><a class="nav-anchor" id="estimation-reoptimizing-1" href="#estimation-reoptimizing-1">Optimizing or Reoptimizing</a></h2><p>Generally, the user will want to reoptimize the parameter vector (and consequently, calculate the Hessian at this new mode) every time they conduct posterior sampling; that is, when:</p><ul><li>the input data are updated with a new quarter of observations or revised</li><li>the model sub-specification is changed</li><li>the model is derived from an existing model with different equilibrium conditions or   measurement equation.</li></ul><p>This behavior can be controlled more finely.</p><h3><a class="nav-anchor" id="Reoptimize-from-a-Specified-Starting-Vector-1" href="#Reoptimize-from-a-Specified-Starting-Vector-1">Reoptimize from a Specified Starting Vector</a></h3><p>Reoptimize the model starting from the parameter values supplied in a specified file. Ensure that you supply an HDF5 file with a variable named <code>params</code> that is the correct dimension and data type.</p><pre><code class="language-julia">m = Model990()
params = load_parameters_from_file(m, &quot;path/to/parameter/file.h5&quot;)
update!(m, params)
estimate(m)</code></pre><h3><a class="nav-anchor" id="Skip-Reoptimization-Entirely-1" href="#Skip-Reoptimization-Entirely-1">Skip Reoptimization Entirely</a></h3><p>You can provide a modal parameter vector and optionally a Hessian matrix calculated at that mode to skip the reoptimization entirely. These values are usually computed by the user previously.</p><p>You can skip reoptimization of the parameter vector entirely.</p><pre><code class="language-julia">m = Model990()
specify_mode!(m, &quot;path/to/parameter/mode/file.h5&quot;)
estimate(m)</code></pre><p>The <code>specify_mode!</code> function will update the parameter vector to the mode and skip reoptimization by setting the <code>reoptimize</code> model setting. Ensure that you supply an HDF5 file with a variable named <code>params</code> that is the correct dimension and data type. (See also the utility function <code>load_parameters_from_file</code>.)</p><h2><a class="nav-anchor" id="Calculating-the-Hessian-1" href="#Calculating-the-Hessian-1">Calculating the Hessian</a></h2><p>By default, <code>estimate</code> will recompute the Hessian matrix. You can skip calculation of the Hessian matrix entirely if you provide a file with a Hessian that has been pre-computed.</p><pre><code class="language-julia">m = Model990()
specify_mode!(m, &quot;path/to/parameter/mode/file.h5&quot;)
specify_hessian(m, &quot;path/to/Hessian/matrix/file.h5&quot;)
estimate(m)</code></pre><p>The <code>specify_hessian</code> function will cause <code>estimate</code> to read in the Hessian matrix rather than calculating it directly.  Ensure that you supply an HDF5 file with a variable named <code>hessian</code> that is the correct dimension and data type. Specifying the Hessian matrix but <em>not</em> the parameter mode results in undefined behavior.</p><p>See [Hessian Approximation] for more details on the Hessian computation. </p><h2><a class="nav-anchor" id="Estimation-routines-1" href="#Estimation-routines-1">Estimation routines</a></h2><h3><a class="nav-anchor" id="Prior,-Likelihood-and-Posterior-calculations-1" href="#Prior,-Likelihood-and-Posterior-calculations-1">Prior, Likelihood and Posterior calculations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.prior" href="#DSGE.prior"><code>DSGE.prior</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>prior(m::AbstractModel{T})</code></p><p>Calculates log joint prior density of m.parameters.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.likelihood" href="#DSGE.likelihood"><code>DSGE.likelihood</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">likelihood{T&lt;:AbstractFloat}(m::AbstractModel, data::Matrix{T};
                              mh::Bool = false, catch_errors::Bool = false)</code></pre><p>Evaluate the DSGE likelihood function. Can handle &quot;two part&quot; estimation where the observed sample contains both a normal stretch of time (in which interest rates are positive) and a stretch of time in which interest rates reach the zero lower bound. If there is a zero-lower-bound period, then we filter over the 2 periods separately.  Otherwise, we filter over the main sample all at once.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The model object</li><li><code>data</code>: matrix of data for observables</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>mh</code>: Whether metropolis_hastings is the caller. If <code>mh=true</code>, the transition matrices for   the zero-lower-bound period are returned in a dictionary.</li><li><code>catch_errors</code>: If <code>mh = true</code>, <code>GensysErrors</code> should always be caught.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.posterior" href="#DSGE.posterior"><code>DSGE.posterior</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">posterior{T&lt;:AbstractFloat}(m::AbstractModel{T}, data::Matrix{T};
                             mh::Bool = false, catch_errors::Bool = false)</code></pre><p>Calculates and returns the log of the posterior distribution for m.parameters:</p><pre><code class="language-none">log posterior = log likelihood + log prior
log Pr(Θ|data)  = log Pr(data|Θ)   + log Pr(Θ)</code></pre><p><strong>Arguments</strong></p><ul><li><code>m</code>: the model object</li><li><code>data</code>: matrix of data for observables</li></ul><p><strong>Optional Arguments</strong></p><p>-<code>mh</code>: Whether metropolis_hastings is the caller. If <code>mh=true</code>, the log likelihood and the   transition matrices for the zero-lower-bound period are also returned. -<code>catch_errors</code>: Whether or not to catch errors of type <code>GensysError</code> or <code>ParamBoundsError</code></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.posterior!" href="#DSGE.posterior!"><code>DSGE.posterior!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">posterior!{T&lt;:AbstractFloat}(m::AbstractModel{T}, parameters::Vector{T}, data::Matrix{T};
                              mh::Bool = false, catch_errors::Bool = false)</code></pre><p>Evaluates the log posterior density at <code>parameters</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: The model object</li><li><code>parameters</code>: New values for the model parameters</li><li><code>data</code>: Matrix of input data for observables</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>mh</code>: Whether metropolis_hastings is the caller. If <code>mh=true</code>, the log likelihood and the   transition matrices for the zero-lower-bound period are also returned.</li><li><code>catch_errors</code>: Whether or not to catch errors of type <code>GensysError</code> or <code>ParamBoundsError</code>.   If <code>mh = true</code>, both should always be caught.</li></ul></div></section><h3><a class="nav-anchor" id="Optimization-1" href="#Optimization-1">Optimization</a></h3><p>See <a href="algorithms.html#algs-optimization-1">Optimization</a></p><h3><a class="nav-anchor" id="Full-Estimation-Routine-1" href="#Full-Estimation-Routine-1">Full Estimation Routine</a></h3><p>See <a href="estimation.html#DSGE.estimate"><code>estimate</code></a></p><h3><a class="nav-anchor" id="Output-Analysis-1" href="#Output-Analysis-1">Output Analysis</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.compute_moments" href="#DSGE.compute_moments"><code>DSGE.compute_moments</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">compute_moments(m::AbstractModel, percent::Float64 = 0.90; verbose::Symbol=:none)</code></pre><p>Computes prior and posterior parameter moments. Tabulates prior mean, posterior mean, and bands in various LaTeX tables stored <code>tablespath(m)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: the model object</li><li><code>percent</code>: the percentage of the mass of draws from Metropolis-Hastings included between   the bands displayed in output tables.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.find_density_bands-Tuple{Array{T,2},AbstractFloat}" href="#DSGE.find_density_bands-Tuple{Array{T,2},AbstractFloat}"><code>DSGE.find_density_bands</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find_density_bands(draws::Matrix, percent::AbstractFloat; minimize::Bool=true)</code></pre><p>Returns a <code>2</code> x <code>cols(draws)</code> matrix <code>bands</code> such that <code>percent</code> of the mass of <code>draws[:,i]</code> is above <code>bands[1,i]</code> and below <code>bands[2,i]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>draws</code>: Matrix of parameter draws (from Metropolis-Hastings, for example)</li><li><code>percent</code>: percent of data within bands (e.g. .9 to get 90% of mass within bands)</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>minimize</code>: if <code>true</code>, choose shortest interval, otherwise just chop off lowest and   highest (percent/2)</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.make_moment_tables-Tuple{DSGE.AbstractModel{T},Array{T<:AbstractFloat,2},AbstractFloat}" href="#DSGE.make_moment_tables-Tuple{DSGE.AbstractModel{T},Array{T<:AbstractFloat,2},AbstractFloat}"><code>DSGE.make_moment_tables</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">make_moment_tables{T&lt;:AbstractFloat}(m::AbstractModel, draws::Matrix{T},
    percent::AbstractFloat; verbose::Symbol = :none)</code></pre><p>Tabulates parameter moments in 3 LaTeX tables:</p><ol><li>For MAIN parameters, a list of prior means, prior standard deviations, posterior means,    and 90% bands for posterior draws</li><li>For LESS IMPORTANT parameters, a list of the prior means, prior standard deviations,    posterior means and 90% bands for posterior draws.</li><li>A list of prior means and posterior means</li></ol><p><strong>Arguments</strong></p><ul><li><code>draws</code>: [n_draws x n_parameters] matrix holding the posterior draws from   Metropolis-Hastings from save/mhsave.h5</li><li><code>percent</code>: the mass of observations we want; 0 &lt;= percent &lt;= 1</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.save_mean_parameters-Tuple{DSGE.AbstractModel{T},Array{T<:AbstractFloat,2}}" href="#DSGE.save_mean_parameters-Tuple{DSGE.AbstractModel{T},Array{T<:AbstractFloat,2}}"><code>DSGE.save_mean_parameters</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">save_mean_parameters{T&lt;:AbstractFloat}(m::AbstractModel, draws::Matrix{T})</code></pre><p>Computes and saves the posterior mean of the parameters.</p><p><strong>Arguments</strong></p><ul><li><code>m</code></li><li><code>draws</code>: n_draws x n_parameters matrix holding the posterior draws from   Metropolis-Hastings</li></ul></div></section><footer><hr/><a class="previous" href="solving.html"><span class="direction">Previous</span><span class="title">Solving the Model</span></a><a class="next" href="algorithms.html"><span class="direction">Next</span><span class="title">Algorithms</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation Details · DSGE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="DSGE.jl logo"/></a><h1>DSGE.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="model_design.html">Model Design</a></li><li><a class="toctext" href="running_existing_model.html">Running An Existing Model</a></li><li><a class="toctext" href="advanced_usage.html">Advanced Usage</a></li><li><a class="toctext" href="input_data.html">Input Data</a></li><li><a class="toctext" href="frbny_data.html">FRBNY Model Input Data</a></li><li class="current"><a class="toctext" href="implementation_details.html">Implementation Details</a><ul class="internal"><li><a class="toctext" href="#The-AbstractModel-Type-and-the-Model-Object-1">The <code>AbstractModel</code> Type and the Model Object</a></li><li><a class="toctext" href="#Defining-Indices-1">Defining Indices</a></li><li><a class="toctext" href="#Parameters:-The-AbstractParameter-Type-1">Parameters: The <code>AbstractParameter</code> Type</a></li><li><a class="toctext" href="#Model-Settings-1">Model Settings</a></li><li><a class="toctext" href="#Type-Interfaces-1">Type Interfaces</a></li></ul></li><li><a class="toctext" href="solving.html">Solving the Model</a></li><li><a class="toctext" href="estimation.html">Estimating the Model</a></li><li><a class="toctext" href="algorithms.html">Algorithms</a></li><li><a class="toctext" href="contributing.html">Contributing to DSGE.jl</a></li><li><a class="toctext" href="MatlabToJuliaTransition.html">MATLAB to Julia Transition</a></li><li><a class="toctext" href="license.html">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="implementation_details.html">Implementation Details</a></li></ul><a class="edit-page" href="https://github.com/FRBNY-DSGE/DSGE.jl/tree/d2ad99f95ab5eb6fa48bb09e4fb9ffecc522b672/docs/src/implementation_details.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Implementation-Details-1" href="#Implementation-Details-1">Implementation Details</a></h1><p>This section describes important functions and implementation features in greater detail. If the user is interested only in running the default model and reproducing the estimation results, this section can be ignored. Additional documentation can also be found in function documentation or in-line.</p><p>This section focuses on what the code does and why.  Docstrings and the code itself (including comments) provides detailed information regarding <em>how</em> these basic procedures are implemented.</p><h2><a class="nav-anchor" id="The-AbstractModel-Type-and-the-Model-Object-1" href="#The-AbstractModel-Type-and-the-Model-Object-1">The <code>AbstractModel</code> Type and the Model Object</a></h2><p>The <code>AbstractModel</code> type provides a common interface for all model objects, which greatly facilitates the implementation of new model specifications. Any concrete subtype of <code>AbstractModel</code> can be passed to any function defined for <code>AbstractModel</code>, provided that the concrete type has the fields that the function expects to be available.</p><p><code>Model990</code> is one example of a concrete subtype of <code>AbstractModel</code> that implements a single specification of the FRBNY DSGE model. All model objects must have these fields so that the interface for <code>AbstractModel</code> objects works correctly.  See <a href="advanced_usage.html#editing-extending-model-1">Editing or Extending a Model</a> for more detail.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.Model990" href="#DSGE.Model990"><code>DSGE.Model990</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Model990{T} &lt;: AbstractModel{T}</code></pre><p>The <code>Model990</code> type defines the structure of the FRBNY DSGE model.</p><p><strong>Fields</strong></p><p><strong>Parameters and Steady-States</strong></p><ul><li><code>parameters::Vector{AbstractParameter}</code>: Vector of all time-invariant model parameters.</li></ul><ul><li><code>steady_state::Vector{AbstractParameter}</code>: Model steady-state values, computed as a function of elements of   <code>parameters</code>.</li></ul><ul><li><code>keys::Dict{Symbol,Int}</code>: Maps human-readable names for all model parameters and   steady-states to their indices in <code>parameters</code> and <code>steady_state</code>.</li></ul><p><strong>Inputs to Measurement and Equilibrium Condition Equations</strong></p><p>The following fields are dictionaries that map human-readible names to row and column indices in the matrix representations of of the measurement equation and equilibrium conditions.</p><ul><li><code>endogenous_states::Dict{Symbol,Int}</code>: Maps each state to a column in the measurement and   equilibrium condition matrices.</li></ul><ul><li><code>exogenous_shocks::Dict{Symbol,Int}</code>: Maps each shock to a column in the measurement and   equilibrium condition matrices.</li></ul><ul><li><code>expected_shocks::Dict{Symbol,Int}</code>: Maps each expected shock to a column in the   measurement and equilibrium condition matrices.</li></ul><ul><li><code>equilibrium_conditions::Dict{Symbol,Int}</code>: Maps each equlibrium condition to a row in the   model&#39;s equilibrium condition matrices.</li></ul><ul><li><code>endogenous_states_augmented::Dict{Symbol,Int}</code>: Maps lagged states to their columns in   the measurement and equilibrium condition equations. These are added after Gensys solves the   model.</li></ul><ul><li><code>observables::Dict{Symbol,Int}</code>: Maps each observable to a row in the model&#39;s measurement   equation matrices.</li></ul><p><strong>Model Specifications and Settings</strong></p><ul><li><code>spec::AbstractString</code>: The model specification identifier, &quot;m990&quot;, cached here for   filepath computation.</li></ul><ul><li><code>subspec::AbstractString</code>: The model subspecification number, indicating that some   parameters from the original model spec (&quot;ss0&quot;) are initialized differently. Cached here for   filepath computation.</li></ul><ul><li><code>settings::Dict{Symbol,Setting}</code>: Settings/flags that affect computation without changing   the economic or mathematical setup of the model.</li></ul><ul><li><code>test_settings::Dict{Symbol,Setting}</code>: Settings/flags for testing mode</li></ul><p><strong>Other Fields</strong></p><ul><li><code>rng::MersenneTwister</code>: Random number generator. Can be is seeded to ensure   reproducibility in algorithms that involve randomness (such as Metropolis-Hastings).</li></ul><ul><li><code>testing::Bool</code>: Indicates whether the model is in testing mode. If <code>true</code>, settings from   <code>m.test_settings</code> are used in place of those in <code>m.settings</code>.</li></ul><ul><li><code>data_series::Dict{Symbol,Vector{Symbol}}</code>: A dictionary that   stores data sources (keys) and lists of series mnemonics   (values). DSGE.jl will fetch data from the Federal Reserve Bank of   St. Louis&#39;s FRED database; all other data must be downloaded by the   user. See <code>load_data</code> for further details.</li></ul></div></section><h2><a class="nav-anchor" id="Defining-Indices-1" href="#Defining-Indices-1">Defining Indices</a></h2><p>The model&#39;s equilibrium conditions and observables are represented as fairly large matrices, and keeping track of which rows and columns correspond to which states, shocks, equations, etc. can be confusing. To improve clarity, we define several dictionaries that map variable names to indices in these matrices:</p><ul><li><code>endogenous_states</code>: Indices of endogenous model states</li><li><code>exogenous_shocks</code>: Indices of exogenous shocks</li><li><code>expected_shocks</code>: Indices of expectation shocks</li><li><code>equilibrium_conditions</code>: Indices of equilibrium condition equations</li><li><code>endogenous_states_augmented</code>: Indices of model states, after model solution   and system augmentation</li><li><code>observables</code>:  Indices of named observables</li></ul><p>This approach has a number of advantages. Most importantly, it is robust to inadvertent typos or indexing errors. Since the actual index number doesn&#39;t matter to us, the user only needs to define the names of their equilibrium conditions, states, and other variables. Adding states is easy - we have only to add them to the appropriate list in the model constructor, and they will be assigned an index.</p><p>As an example, consider the model&#39;s equilibrium conditions. The canonical representation of the equilibrium conditions is</p><pre><code class="language-none">Γ0 s_t = Γ1 s_{t-1} + C + Ψ ε_t + Π η_t</code></pre><p>where <code>Γ0</code>, <code>Γ1</code>, <code>C</code>, <code>Ψ</code>, and <code>Π</code> are matrices of coefficients for <code>s_t</code> (states at time <code>t</code>), <code>s_{t-1}</code> (lagged states), <code>ε_t</code> (exogenous shocks) and <code>η_t</code> (expectational shocks). Each row of these matrices corresponds to an equilibrium condition, which we define using a descriptive name (for example, we name the consumption Euler equation <code>:euler</code>). States (columns of <code>Γ0</code> and <code>Γ1</code>), exogenous shocks (columns of <code>Ψ</code>), and expectational shocks (columns <code>Π</code>) also have names.</p><h2><a class="nav-anchor" id="Parameters:-The-AbstractParameter-Type-1" href="#Parameters:-The-AbstractParameter-Type-1">Parameters: The <code>AbstractParameter</code> Type</a></h2><p>The <code>AbstractParameter</code> type implements our notion of a model parameter: a time-invariant, unobserved value that has economic significance in the model&#39;s equilibrium conditions. We estimate the model to find the values of these parameters.</p><p>Though all parameters are time-invariant, each has different features. Some parameters are scaled for use in the model&#39;s equilibrium conditions and measurement equations.  During optimization, parameters can be transformed from model space to the real line via one of three different transformations. These transformations are also defined as types, and require additional information for each parameter. Finally, steady-state parameters are not estimated directly, but are calculated as a function of other parameters.</p><p>These various requirements are nicely addressed using a parameterized type hierarchy.</p><ul><li><code>AbstractParameter{T&lt;:Number}</code>: The common abstract supertype for all   parameters.     - <code>Parameter{T&lt;:Number, U&lt;:Transform}</code>: The abstract supertype for       parameters that are directly estimated.         - <code>UnscaledParameter{T&lt;:Number, U:&lt;Transform}</code>: Concrete type for           parameters that do not need to be scaled for equilibrium conditions.         - <code>ScaledParameter{T&lt;:Number, U:&lt;Transform}</code>: Concrete type for           parameters that are scaled for equilibrium conditions.     - <code>SteadyStateParameter{T&lt;:Number}</code>: Concrete type for steady-state       parameters.</li></ul><p>All <code>Parameter</code>s have the fields defined in <code>UnscaledParameter</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.UnscaledParameter" href="#DSGE.UnscaledParameter"><code>DSGE.UnscaledParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UnscaledParameter{T&lt;:Number,U&lt;:Transform} &lt;: Parameter{T,U}</code></pre><p>Time-invariant model parameter whose value is used as-is in the model&#39;s equilibrium conditions.</p><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code>: Parameter name. For maximum clarity, <code>key</code>   should conform to the guidelines established in the DSGE Style Guide.</li><li><code>value::T</code>: Parameter value. Initialized in model space (guaranteed   to be between <code>valuebounds</code>), but can be transformed between model   space and the real line via calls to <code>transform_to_real_line</code> and <code>transform_to_model_space</code>.</li><li><code>valuebounds::Interval{T}</code>: Bounds for the parameter&#39;s value in model space.</li><li><code>transform_parameterization::Interval{T}</code>: Parameters used to   transform <code>value</code> between model space and the real line.</li><li><code>transform::U</code>: Transformation used to transform <code>value</code> between   model space and real line.</li><li><code>prior::NullablePrior</code>: Prior distribution for parameter value.</li><li><code>fixed::Bool</code>: Indicates whether the parameter&#39;s value is fixed rather than estimated.</li><li><code>description::AbstractString</code>:  A short description of the parameter&#39;s economic   significance.</li><li><code>tex_label::AbstractString</code>: String for printing the parameter name to LaTeX.</li></ul></div></section><p><code>ScaledParameters</code> also have the following fields:</p><ul><li><code>scaledvalue::T</code>: Parameter value scaled for use in <code>eqcond.jl</code></li><li><code>scaling::Function</code>: Function used to scale parameter value for use in   equilibrium conditions.</li></ul><p><em>Note:</em> Though not strictly necessary, defining a scaling with the parameter object allows for much a much cleaner definition of the equilibrium conditions.</p><p>Because the values of <code>SteadyStateParameter</code>s are directly computed as a function of <code>ScaledParameter</code>s and <code>UnscaledParameter</code>s, they only require 4 fields:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.SteadyStateParameter" href="#DSGE.SteadyStateParameter"><code>DSGE.SteadyStateParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SteadyStateParameter{T} &lt;: AbstractParameter{T}</code></pre><p>Steady-state model parameter whose value depends upon the value of other (non-steady-state) <code>Parameter</code>s. <code>SteadyStateParameter</code>s must be constructed and added to an instance of a model object <code>m</code> _after_ all other model <code>Parameter</code>s have been defined. Once added to <code>m</code>, <code>SteadyStateParameter</code>s are stored in <code>m.steady_state</code>. Their values are calculated and set by <code>steadystate!(m)</code>, rather than being estimated directly. <code>SteadyStateParameter</code>s do not require transformations from the model space to the real line or scalings for use in equilibrium conditions.</p><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code>: Parameter name. Should conform to the guidelines   established in the DSGE Style Guide.</li><li><code>value::T</code>: The parameter&#39;s steady-state value.</li><li><code>description::AbstractString</code>: Short description of the parameter&#39;s economic significance.</li><li><code>tex_label::AbstractString</code>: String for printing parameter name to LaTeX.</li></ul></div><div><pre><code class="language-none">SteadyStateParameter{T&lt;:Number}(key::Symbol, value::T;
                                description::AbstractString = &quot;&quot;,
                                tex_label::AbstractString = &quot;&quot;)</code></pre><p>SteadyStateParameter constructor with optional <code>description</code> and <code>tex_label</code> arguments.</p></div></section><h2><a class="nav-anchor" id="Model-Settings-1" href="#Model-Settings-1">Model Settings</a></h2><p>The <code>Setting</code> type implements computational settings that affect how the code runs without affecting the mathematical definition of the model. These include flags (e.g. whether or not to recompute the Hessian), parameterization for the Metropolis-Hastings algorithm (e.g. number of times to draw from the posterior distribution), and the vintage of data being used (<code>Setting</code> is a parametric type - a <code>Setting{T&lt;:Any}</code>, so Booleans, Numbers, and Strings can all be turned into <code>Setting</code>s). They are stored centrally in the <code>settings</code> dictionary within the model object.</p><p>Why implement a <code>Setting</code> type when we could put their values directly into the source code or dictionary? The most obvious answer is that the parametric type allows us to implement a single interface for all <code>Setting</code>s (Booleans, Strings, etc.), so that when we access a particular setting during the estimation and forecast steps, we don&#39;t have to think about the setting&#39;s type.</p><p><code>Setting</code>s play an important role in addition to providing useful abstraction. Estimating and forecasting the FRBNY DSGE model takes many hours of computation time and creates a lot of output files. It is useful to be able to compare model output from two different models whose settings differ slightly (for example, consider two identical models that use different vintages of data as input). A central feature of the <code>Setting</code> type is a mechanism that generates unique, meaningful filenames when code is executed with different settings. Specifically, when a setting takes on a non-default value, a user-defined setting code (along with the setting&#39;s value) are appended to all output files generated during execution.</p><p>The <code>Setting{T&lt;:Any}</code> type is defined as follows:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.Setting" href="#DSGE.Setting"><code>DSGE.Setting</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Setting{T}</code></pre><p>The <code>Setting</code> type is an interface for computational settings that affect how the code runs without affecting the mathematical definition of the model. It also provides support for non-conflicting file names for output of 2 models that differ only in the values of their computational settings.</p><p><strong>Fields</strong></p><ul><li><code>key::Symbol</code>: Name of setting</li><li><code>value::T</code>: Value of setting</li><li><code>print::Bool</code>: Indicates whether to append this setting&#39;s code and value to output file   names. If true, output file names will include a suffix of the form <code>_code1=val1_code2=val2</code>   etc. where codes are listed in alphabetical order.</li><li><code>code::AbstractString</code>: string of &lt;=4 characters to print to output file suffixes when   <code>print=true</code>.</li><li><code>description::AbstractString</code>: Short description of what the setting is used for.</li></ul></div></section><p>To update the value of an existing function, the user has two options. First, the user may use the <code>&lt;=</code> syntax as shown in the <a href="running_existing_model.html#Running-with-Default-Settings-1">Running with Default Settings</a> section. However, for this to work properly, it is essential that the setting&#39;s <code>key</code> field be exactly the same as that of an existing entry in <code>m.settings</code>. Otherwise, an additional entry will be added to <code>m.settings</code> and the old setting will be the one accessed from other all routines. A potentially safer, though clunkier, option is to use the <a href="implementation_details.html#DSGE.update!"><code>update!</code></a> method.</p><h2><a class="nav-anchor" id="Type-Interfaces-1" href="#Type-Interfaces-1">Type Interfaces</a></h2><h3><a class="nav-anchor" id="AbstractModel-Interface-1" href="#AbstractModel-Interface-1"><code>AbstractModel</code> Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.update!" href="#DSGE.update!"><code>DSGE.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update!{T}(pvec::ParameterVector{T}, values::Vector{T})</code></pre><p>Update all parameters in <code>pvec</code> that are not fixed with <code>values</code>. Length of <code>values</code> must equal length of <code>pvec</code>.</p></div><div><pre><code class="language-none">update!{T&lt;:AbstractFloat}(m::AbstractModel, values::Vector{T})</code></pre><p>Update <code>m.parameters</code> with <code>values</code>, recomputing the steady-state parameter values.</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>: the model object</li><li><code>values</code>: the new values to assign to non-steady-state parameters.</li></ul></div><div><pre><code class="language-none">update!(a::Setting, b::Setting)</code></pre><p>Update <code>a</code> with the fields of <code>b</code> if:</p><ul><li>The <code>key</code> field is updated if <code>a.key == b.key</code> </li><li>The <code>print</code> boolean and <code>code</code> string are overwritten if <code>a.print</code> is false and   <code>b.print</code> is true, or <code>a.print</code> is true, <code>b.print</code> is false, and   b.code is non-empty.</li><li>The <code>description</code> field is updated if <code>b.description</code> is nonempty</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.transform_to_model_space!" href="#DSGE.transform_to_model_space!"><code>DSGE.transform_to_model_space!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transform_to_model_space!{T&lt;:AbstractFloat}(m::AbstractModel, values::Vector{T})</code></pre><p>Transforms <code>values</code> from the real line to the model space, and assigns <code>values[i]</code> to <code>m.parameters[i].value</code> for non-steady-state parameters. Recomputes the steady-state paramter values.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: the model object</li><li><code>values</code>: the new values to assign to non-steady-state parameters.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.load_parameters_from_file" href="#DSGE.load_parameters_from_file"><code>DSGE.load_parameters_from_file</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">load_parameters_from_file(m::AbstractModel,path::AbstractString)</code></pre><p>Returns a vector of parameters, read from a file, suitable for updating <code>m</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.specify_mode!" href="#DSGE.specify_mode!"><code>DSGE.specify_mode!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">specify_mode!(m::AbstractModel, mode_file::AbstractString=&quot;&quot;; verbose=:low)</code></pre><p>Updates the values of <code>m.parameters</code> with the values from <code>mode_file</code>. Sets <code>reoptimize</code> setting to <code>false</code>.</p><p>Usage: should be run before calling <code>estimate(m)</code>, e.g.:</p><pre><code class="language-none">m = Model990()
specify_mode!(m, modefile)
estimate(m)</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.specify_hessian" href="#DSGE.specify_hessian"><code>DSGE.specify_hessian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">specify_hessian(m::AbstractModel, path::AbstractString=&quot;&quot;; verbose=:low)</code></pre><p>Specify a Hessian matrix calculated at the posterior mode to use in the model estimation. If no path is provided, will attempt to detect location.</p></div></section><h3><a class="nav-anchor" id="Parameter-Interface-1" href="#Parameter-Interface-1"><code>Parameter</code> Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.parameter" href="#DSGE.parameter"><code>DSGE.parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">parameter{T,U&lt;:Transform}(key::Symbol, value::T, valuebounds = (value,value),
                          transform_parameterization = (value,value),
                          transform = Untransformed(), prior = NullablePrior(),
                          fixed = true, scaling::Function = identity, description = &quot;&quot;,
                          tex_label::AbstractString = &quot;&quot;)</code></pre><p>By default, returns a fixed <code>UnscaledParameter</code> object with key <code>key</code> and value <code>value</code>. If <code>scaling</code> is given, a <code>ScaledParameter</code> object is returned.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.parameter-Tuple{DSGE.ScaledParameter{T<:Number,U<:DSGE.Transform},T<:Number}" href="#DSGE.parameter-Tuple{DSGE.ScaledParameter{T<:Number,U<:DSGE.Transform},T<:Number}"><code>DSGE.parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parameter{T&lt;:Number,U&lt;:Transform}(p::ScaledParameter{T,U}, newvalue::T)</code></pre><p>Returns a ScaledParameter with value field equal to <code>newvalue</code> and scaledvalue field equal to <code>p.scaling(newvalue)</code>. If <code>p</code> is a fixed parameter, it is returned unchanged.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.parameter-Tuple{DSGE.UnscaledParameter{T<:Number,U<:DSGE.Transform},T<:Number}" href="#DSGE.parameter-Tuple{DSGE.UnscaledParameter{T<:Number,U<:DSGE.Transform},T<:Number}"><code>DSGE.parameter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parameter{T&lt;:Number,U&lt;:Transform}(p::UnscaledParameter{T,U}, newvalue::T)</code></pre><p>Returns an UnscaledParameter with value field equal to <code>newvalue</code>. If <code>p</code> is a fixed parameter, it is returned unchanged.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.transform_to_model_space-Tuple{DSGE.Parameter{T,DSGE.Untransformed},T}" href="#DSGE.transform_to_model_space-Tuple{DSGE.Parameter{T,DSGE.Untransformed},T}"><code>DSGE.transform_to_model_space</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">transform_to_model_space{T&lt;:Number, U&lt;:Transform}(p::Parameter{T,U}, x::T)</code></pre><p>Transforms <code>x</code> from the real line to lie between <code>p.valuebounds</code> without updating <code>p.value</code>. The transformations are defined as follows, where (a,b) = p.transform_parameterization and c a scalar (default=1):</p><ul><li>Untransformed: <code>x</code></li><li>SquareRoot:    <code>(a+b)/2 + (b-a)/2 * c * x/sqrt(1 + c^2 * x^2)</code></li><li>Exponential:   <code>a + exp(c*(x-b))</code></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.transform_to_real_line" href="#DSGE.transform_to_real_line"><code>DSGE.transform_to_real_line</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transform_to_real_line{T&lt;:Number, U&lt;:Transform}(p::Parameter{T,U}, x::T = p.value)</code></pre><p>Transforms <code>p.value</code> from model space (between <code>p.valuebounds</code>) to the real line, without updating <code>p.value</code>. The transformations are defined as follows, where (a,b) = p.transform_parameterization, c a scalar (default=1), and x = p.value:</p><ul><li>Untransformed: x</li><li>SquareRoot:   (1/c)*cx/sqrt(1 - cx^2), where cx =  2 * (x - (a+b)/2)/(b-a)</li><li>Exponential:   a + exp(c*(x-b))</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.update!-Tuple{Array{DSGE.AbstractParameter{T},1},Array{T,1}}" href="#DSGE.update!-Tuple{Array{DSGE.AbstractParameter{T},1},Array{T,1}}"><code>DSGE.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">update!{T}(pvec::ParameterVector{T}, values::Vector{T})</code></pre><p>Update all parameters in <code>pvec</code> that are not fixed with <code>values</code>. Length of <code>values</code> must equal length of <code>pvec</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.update-Tuple{Array{DSGE.AbstractParameter{T},1},Array{T,1}}" href="#DSGE.update-Tuple{Array{DSGE.AbstractParameter{T},1},Array{T,1}}"><code>DSGE.update</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">update{T}(pvec::ParameterVector{T}, values::Vector{T})</code></pre><p>Returns a copy of <code>pvec</code> where non-fixed parameter values are updated to <code>values</code>. <code>pvec</code> remains unchanged. Length of <code>values</code> must equal length of <code>pvec</code>.</p></div></section><h3><a class="nav-anchor" id="Setting-Interface-1" href="#Setting-Interface-1"><code>Setting</code> Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.default_test_settings!-Tuple{DSGE.AbstractModel{T}}" href="#DSGE.default_test_settings!-Tuple{DSGE.AbstractModel{T}}"><code>DSGE.default_test_settings!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">default_test_settings!(m::AbstractModel)</code></pre><p>The following Settings are constructed, initialized and added to <code>m.test_settings</code>. Their purposes are identical to those in <code>m.settings</code>, but these values are used to test DSGE.jl.</p><p><strong>I/O Locations and identifiers</strong></p><ul><li><code>saveroot::Setting{ASCIIString}</code>: A temporary directory in /tmp/</li><li><code>dataroot::Setting{ASCIIString}</code>: dsgeroot/test/reference/</li><li><code>data_vintage::Setting{ASCIIString}</code>: &quot;_REF&quot;</li></ul><p><strong>Metropolis-Hastings</strong></p><ul><li><code>n_mh_simulations::Setting{Int}</code>: 100</li><li><code>n_mh_blocks::Setting{Int}</code>: 1</li><li><code>n_mh_burn::Setting{Int}</code>: 0</li><li><code>mh_thin::Setting{Int}</code>: 1</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.get_setting-Tuple{DSGE.AbstractModel{T},Symbol}" href="#DSGE.get_setting-Tuple{DSGE.AbstractModel{T},Symbol}"><code>DSGE.get_setting</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_setting(m::AbstractModel, setting::Symbol)</code></pre><p>Returns the value of the setting</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSGE.update!-Tuple{DSGE.Setting{T},DSGE.Setting{T}}" href="#DSGE.update!-Tuple{DSGE.Setting{T},DSGE.Setting{T}}"><code>DSGE.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">update!(a::Setting, b::Setting)</code></pre><p>Update <code>a</code> with the fields of <code>b</code> if:</p><ul><li>The <code>key</code> field is updated if <code>a.key == b.key</code> </li><li>The <code>print</code> boolean and <code>code</code> string are overwritten if <code>a.print</code> is false and   <code>b.print</code> is true, or <code>a.print</code> is true, <code>b.print</code> is false, and   b.code is non-empty.</li><li>The <code>description</code> field is updated if <code>b.description</code> is nonempty</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.<=-Tuple{DSGE.AbstractModel{T},DSGE.Setting{T}}" href="#Base.<=-Tuple{DSGE.AbstractModel{T},DSGE.Setting{T}}"><code>Base.&lt;=</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">(&lt;=)(m::AbstractModel, s::Setting)</code></pre><p>Syntax for adding a setting to a model/overwriting a setting via <code>m &lt;= Setting(...)</code></p></div></section><footer><hr/><a class="previous" href="frbny_data.html"><span class="direction">Previous</span><span class="title">FRBNY Model Input Data</span></a><a class="next" href="solving.html"><span class="direction">Next</span><span class="title">Solving the Model</span></a></footer></article></body></html>
